Emscripten creates a lot of glue code, but automates everything allowing you to focus on logic (good during early phases of project).
Direct binding is probably more efficient however - 




Wasmer - standalone universal WebAssembly runtime (like JRE) to run .wasm files on different native OS. Designed to:
1. Enable programs to run in any programming language
2. Enable extremely portable binaries to run unmodified on any "OS" supported by Wasmer (for example, Linux, macOS, Windows and FreeBSD).
3. Act as a secure bridge for Wasm modules to interact with native "OS" functionality, via Application Binary Interfaces (ABIs) such as WASI and Emscripten (version 1.38.43 and earlier).

WASI - WebAssembly System Interface - e.g. for writing files, network, device I/O
It can apparently (?) be used to build standalone. It seems this requires a VM like Wasmer, Wasmtime etc. 
https://alexene.dev/2020/08/17/webassembly-without-the-browser-part-1.html

---JavaScript

https://www.wasm.builders/gunjan_0307/compiling-javascript-to-wasm-34lk


---Zig

zig - another compiler that can do what emscripten does - compile  to wasm
(why did zig come up? because of comment here: https://www.reddit.com/r/WebAssembly/comments/odidnp/emscripten_alternatives/

"Zig can compile C and C++ code to WebAssembly (freestanding or WASI).
 zig cc --target=wasm32-wasi --shared -o module.wasm *.c
 zig c++ --target=wasm32-freestanding --shared -o module.wasm *.cpp
"

)


---AssemblyScript

https://www.assemblyscript.org/introduction.html#from-a-webassembly-perspective

-No VM. Just WASM bytecode.
-"What are good use cases for AssemblyScript? Computation-heavy logic like image manipulation, hot game logic, specialized algorithms, emulators"
-"Can AssemblyScript be used in non-standard ways, say outside of the browser? Absolutely! AssemblyScript modules are self-contained and run anywhere where WebAssembly is supported."

https://blog.suborbital.dev/assemblyscript-vs-rust-for-your-wasm-app

DECISION: At the end of the day, AssemblyScript may be useful if only to learn WebAssembly bytecode itself. Could install it, do some compiles, and see if this gets me ahead with WebAssembly bytecode which *is* a useful skill.
https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format

Real world performance improvement use case, shows how little can actually be gained by using WebAssembly and at what degree of effort and understanding of the underlying platform. Probably better to opt for SIMD withing JS, and WebGPU.

https://surma.dev/things/js-to-asc/
https://betterprogramming.pub/how-fast-is-webassembly-versus-javascript-bc0eca058a54

---WebGPU

"Both Chrome and Firefox support WebGPU with SPIR-V, with work ongoing for the WGSL front-end. Safari supports WebGPU with WSL." (probably need to turn them on via special flags or use Chrome Canary)

How can we make Raycaster more GPU friendly?

Innermost loop appears to be where problem lies, as it is strictly dependent on
how many different coloured columns (DDA edge transitions) there are in a given
view.

You might finish a 64-step warp and then realise that the column is not yet complete, and have to do another.

It is the degree of variability in this that makes it problematic. If it were just between say 64 and 256 steps, we'd be golden. But for a decent resolution (1024 vertical) we'd need 16 runs of 64 - per screen column (min 1024, more likely 1600 or so)!

We need to treat each column (probably) as an individual element in the parallel processing stream of the GPU.
But then that inner loop fucks us hard.


...Ah, but does it? Silverman will be per-ray (with gaps filled in after).

32-64 items execute in lockstep as a single hardware thread on a SIMD unit... this is called a warp or wavefront.


