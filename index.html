<!DOCTYPE html>
<html>
<head>
    <title>Voxel Space project demonstration</title>
    <meta charset="UTF-8">
    <meta name="description" content="Demonstration of the Voxel Space technique">
    <meta name="keywords" content="Voxel, VoxelSpace, Voxel Space, Comanche, landscape, rendering">
    <style>
        html, body {margin: 0; height: 100%; overflow: hidden}
        canvas { width: 100%; height: 100%; }
        a { color: white; }
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
            z-index:100;
            color: white;
            font-family: "Arial", Times, serif;
            font-size: 120%;
            }
        #fps {
            float: right;
            position: absolute;
            top: 0px;
            right: 10px;
            z-index:100;
            padding: 5px;
            color: white;
            font-family: "Arial", Times, serif;
            font-size: 120%;
            }
    </style>
</head>

<body scroll="no">

<div id="fps">
</div>

<div id="info">
    Fly controls
    <b>WASD</b> or <b>Cursor Keys</b> or <b>left click</b> move, <b>R|F</b> up | down, <b>Q|E</b> pitch,
<br>

<select name="Mapselector" size="1" onchange="LoadMap(this.value);" value="C1W;D1">
<option value="C1W;D1">Map C1W</option>
<option value="C2W;D2">Map C2W</option>
<option value="C3;D3">Map C3</option>
<option value="C4;D4">Map C4</option>
<option value="C5W;D5">Map C5W</option>
<option value="C6W;D6">Map C6W</option>
<option value="C7W;D7">Map C7W</option>
<option value="C8;D6">Map C8</option>
<option value="C9W;D9">Map C9W</option>
<option value="C10W;D10">Map C10W</option>
<option value="C11W;D11">Map C11W</option>
<option value="C12W;D11">Map C12W</option>
<option value="C13;D13">Map C13</option>
<option value="C14;D14">Map C14</option>
<option value="C14W;D14">Map C14W</option>
<option value="C15;D15">Map C15</option>
<option value="C16W;D16">Map C16W</option>
<option value="C17W;D17">Map C17W</option>
<option value="C18W;D18">Map C18W</option>
<option value="C19W;D19">Map C19W</option>
<option value="C20W;D20">Map C20W</option>
<option value="C21;D21">Map C21</option>
<option value="C22W;D22">Map C22W</option>
<option value="C23W;D21">Map C23W</option>
<option value="C24W;D24">Map C24W</option>
<option value="C25W;D25">Map C25W</option>
<option value="C26W;D18">Map C26W</option>
<option value="C27W;D15">Map C27W</option>
<option value="C28W;D25">Map C28W</option>
<option value="C29W;D16">Map C29W</option>
</select>

<label for="zNear">zNear</label>
<input id="zNear" type="range" min="1" max="1000" step="1" oninput="camera.zNear = valueAsNumber">

<label for="zFar">zFar</label>
<input id="zFar" type="range" min="100" max="10000" step="1" oninput="camera.zFar = valueAsNumber">

<label for="horizon">horizon pos</label>
<input id="horizon" type="range" min="0" max="560" step="1" oninput="camera.horizon = valueAsNumber">

<label for="columnscale">columnscale</label>
<input id="columnscale" type="range" min="1" max="10" step="0.01" oninput="camera.columnscale = valueAsNumber">

<label for="yk">vfov</label>
<input id="yk" type="range" min="0.000001" max="1.0" step="0.000001" oninput="camera.setyk(valueAsNumber)">

<label for="hfov">hfov</label>
<input id="hfov" type="range" min="0" max="3.141" step="0.01" oninput="camera.hfov = valueAsNumber">



<a href="https://github.com/s-macke/VoxelSpace">Github project page</a>

</div>

<canvas id="fullscreenCanvas" width="800" height="400">
    Your browser does not support the canvas element.
</canvas>

<script>
"use strict";

// ---------------------------------------------
// Viewer information
var input =
{
    forwardbackward: 0,
    leftright:       0,
    updown:          0,
    lookup:          false,
    lookdown:        false,
    mouseposition:   null,
    keypressed:      false
}

var camera =
{
    x:        512., // x position on the map
    y:        800., // y position on the map
    height:   600., // height of the camera
    angle:    -1.570796327, // direction of the camera
    horizon:  0, //280., // horizon position (look up and down)
    zNear: 1.,   // near plane distance
    zFar: 10000.,   // far plane distance
    yk:       0.5,
    hfov: 1.57079633,
    sliderDragged: true,//false,
    setyk: function(value) {
    //this.sliderDragged = true; 
    console.log("!");
    this.yk = value;},
    columnscale: 1.,
    
    //input: input
};

// ---------------------------------------------
// Landscape data

var map =
{
    width:    1024,
    height:   1024,
    shift:    10,  // power of two: 2^10 = 1024
    altitude: new Uint8Array(1024*1024), // 1024 * 1024 byte array with height information
    color:    new Uint32Array(1024*1024) // 1024 * 1024 int array with RGB colors
};

// ---------------------------------------------
// Screen data

var screendata =
{
    canvas:    null,
    context:   null,
    imagedata: null,

    bufarray:  null, // color data
    buf8:      null, // the same array but with bytes
    buf32:     null, // the same array but with 32-Bit words

    backgroundcolor: 0xFF00A0F0 //BGR
};

// ---------------------------------------------
// Keyboard and mouse interaction


var updaterunning = false;

var time = new Date().getTime();


// for fps display
var timelastframe = new Date().getTime();
var frames = 0;

var ymin;// = new Int32Array(screenwidth);

// ---------------------------------------------
// The main render routine

function Render()
{
    let mapwidthperiod = map.width - 1;
    let mapheightperiod = map.height - 1;

    let screenwidth = screendata.canvas.width|0;
    let sinang = Math.sin(camera.angle);
    let cosang = Math.cos(camera.angle);
    //let tanang = Math.tan(camera.angle) / 2;
    //let sinang2 = Math.sin(camera.angle-hhfov);
    //let cosang2 = Math.cos(camera.angle-hhfov);
    //let sinang3 = Math.sin(camera.angle+hhfov);
    //let cosang3 = Math.cos(camera.angle+hhfov);
    
    //TODO what if screen width changes?
    for (let x = 0; x < screenwidth; x++)
        ymin[x] = screendata.canvas.height; //TODO OPTIMISE

    let deltaz = 1.;
    let buf32 = screendata.buf32;
    
    // Draw from front to back
    let zNear = camera.zNear;
    let zFar  = camera.zFar;
    let height = camera.height;
    let horizon = camera.horizon|0;
    let camx = camera.x;
    let camy = camera.y;
    let camangle = camera.angle;
    let mapaltitude = map.altitude;
    let mapcolor = map.color;
    let mapshift = map.shift;
    //let screenwidthinv = 1. / screenwidth;
    let yk = camera.yk;
    let columnscale = camera.columnscale;
    let hfov = camera.hfov;
    let hhfov = camera.hfov / 2;//half horizontal fov
    
    let lx = Math.sin(camangle-hhfov);
    let ly = Math.cos(camangle-hhfov);
    
    let rx = Math.sin(camangle+hhfov);
    let ry = Math.cos(camangle+hhfov);
    
    for (let z = zNear; z < zFar; z += deltaz) //for each ray step
    {
        //get float world space map coords we sample at L,R edges of screen,
        //at this current depth (z). (consider camera lateral arc from top)
        //90 degree FoV, as cos and sine are offset 90 degrees from each other?
        //without *z, this describes unit circle. 
        //Stepping between the two positions representing outer edges of screen,
        //combined with increasing z, causes rays to diverge horizontally.
        
        let maplxo =  lx * z; //-cosang * z - sinang * z;
        let maplyo =  ly * z; // sinang * z - cosang * z;
        let maprxo =  rx * z; // cosang * z - sinang * z;
        let mapryo =  ry * z; //-sinang * z - cosang * z;
        
        //let maplxo =  -cosang * z - sinang * z;
        //let maplyo =   sinang * z - cosang * z;
        //let maprxo =   cosang * z - sinang * z;
        //let mapryo =  -sinang * z - cosang * z;
        //TODO get our custom points' calc above to have same signs / rotation etc.
                
        //world map x,y change as we advance along this ray; derived from 
        //accelerating z as we move farther along the ray, hence in z loop.
        //NOTE: * screenwidthinv; is slower: eliminates a JIT optimisation?
        let dx = (maprxo - maplxo) / screenwidth;
        let dy = (mapryo - maplyo) / screenwidth;
        //console.log("d=", dx, dy);
        
        //world map coordinates (float)
        let maplx = maplxo + camx;
        let maply = maplyo + camy;
        let maprx = maprxo + camx;
        let mapry = mapryo + camy;
        /*
        if (z > 900 && z < 1004) 
        {
            //console.log(maplx, maply, " | ", maprx, mapry); 
            let lmx = Math.floor(maplx) & mapwidthperiod;
            let lmy = Math.floor(maply) & mapwidthperiod;
            let rmx = Math.floor(maprx) & mapwidthperiod;
            let rmy = Math.floor(mapry) & mapwidthperiod;
            console.log(lmx, lmy, rmx, rmy);
        }
        */

        //div-by-z causes rays to diverge vertically (no angles stored).
        //higher yk = narrower vertical FoV.
        let invz = yk * 1000. / z; 
        //let invz = yk * z; 
        
        let xStart = 0;
        let xEnd = screenwidth;
        for (let x = xStart; x < xEnd; x++) //for each ray
        {
            //map 1D coords: cheap modulo wrap on x & y + upshift y.
            let mapoffset = ((Math.floor(maply) & mapwidthperiod) << mapshift) + (Math.floor(maplx) & mapheightperiod);
            let ytop = (height - columnscale * mapaltitude[mapoffset]) * invz + horizon|0;
            
            //draw the vertical line segment...
            let ybot = ymin[x];
            let flag = ytop <= ybot ? 1 : 0; // just <?
            ytop = ytop < 0 ? 0 : ytop;   
            
            // get offset on screen for the vertical line
            let offset = ((ytop * screenwidth) + x); //init.
            for (let k = ytop; k < ybot; k++)
            {
                buf32[offset]  = flag * mapcolor[mapoffset];
                offset        += flag * screenwidth; //increase for line above.
            }
            //...draw the vertical line segment.
            
            //...This variable loop length is where the problem is for GPU.
            //Need to restrict it to warp or wavefront size, or multiple thereof
            //(32 or 64 "threads" / "runs of pixels" at a time.)
            
            ymin[x] = ytop < ymin[x] ? ytop : ymin[x];
            
            //interpolate (gradually "rasterise") between start and end map tile
            maplx += dx;
            maply += dy;
        }
        //orthographic z delta from camera centre. i.e. regardless of the angle
        //of each ray off camera centre, its z stepping is the same,
        //as in a sliced CT-scan style view (but perspective, not ortho).
        deltaz += 0.01; //OPTIMISE increments further away to be greater.
    }
}


// ---------------------------------------------
// Draw the next frame

function Draw()
{
    updaterunning = true;
    UpdateCamera();
    DrawBackground();
    Render();
    Flip();
    frames++;
/*
    if ((!input.keypressed) || (!camera.sliderDragged))
    {
        updaterunning = false;
        console.log("nada");
    } else
    */
    {
        window.requestAnimationFrame(Draw, 0);
    }
}

// ---------------------------------------------
// Init routines

// Util class for downloading the png
function DownloadImagesAsync(urls) {
    return new Promise(function(resolve, reject) {

        var pending = urls.length;
        var result = [];
        if (pending === 0) {
            resolve([]);
            return;
        }
        urls.forEach(function(url, i) {
            var image = new Image();
            //image.addEventListener("load", function() {
            image.onload = function() {
                var tempcanvas = document.createElement("canvas");
                var tempcontext = tempcanvas.getContext("2d");
                tempcanvas.width = map.width;
                tempcanvas.height = map.height;
                tempcontext.drawImage(image, 0, 0, map.width, map.height);
                result[i] = tempcontext.getImageData(0, 0, map.width, map.height).data;
                pending--;
                if (pending === 0) {
                    resolve(result);
                }
            };
            image.src = url;
        });
    });
}

function LoadMap(filenames)
{
    var files = filenames.split(";");
    DownloadImagesAsync(["maps/"+files[0]+".png", "maps/"+files[1]+".png"]).then(OnLoadedImages);
}

function OnLoadedImages(result)
{
    var datac = result[0];
    var datah = result[1];
    for(var i=0; i<map.width*map.height; i++)
    {
        map.color[i] = 0xFF000000 | (datac[(i<<2) + 2] << 16) | (datac[(i<<2) + 1] << 8) | datac[(i<<2) + 0];
        map.altitude[i] = datah[i<<2];
    }
    Draw();
}

function OnResizeWindow()
{
    screendata.canvas = document.getElementById('fullscreenCanvas');

    var aspect = window.innerWidth / window.innerHeight;

    screendata.canvas.width = window.innerWidth<800?window.innerWidth:800;
    screendata.canvas.height = screendata.canvas.width / aspect;

    if (screendata.canvas.getContext)
    {
        screendata.context = screendata.canvas.getContext('2d');
        screendata.imagedata = screendata.context.createImageData(screendata.canvas.width, screendata.canvas.height);
    }

    screendata.bufarray = new ArrayBuffer(screendata.imagedata.width * screendata.imagedata.height * 4);
    screendata.buf8     = new Uint8Array(screendata.bufarray);
    screendata.buf32    = new Uint32Array(screendata.bufarray);
    
    ymin = new Int32Array(screendata.canvas.width);
    
    Draw();
}


// Update the camera for next frame. Dependent on keypresses
function UpdateCamera()
{
    var current = new Date().getTime();

    input.keypressed = false;
    if (input.leftright != 0)
    {
        camera.angle += input.leftright*0.1*(current-time)*0.03;
        input.keypressed = true;
    }
    if (input.forwardbackward != 0)
    {
        camera.x += input.forwardbackward * Math.sin(camera.angle) * (current-time)*0.03;
        camera.y += input.forwardbackward * Math.cos(camera.angle) * (current-time)*0.03;
        input.keypressed = true;
    }
    if (input.updown != 0)
    {
        camera.height += input.updown * (current-time)*0.03;
        input.keypressed = true;
    }
    /*
    if (input.lookup)
    {
        camera.horizon += 2 * (current-time)*0.03;
        input.keypressed = true;
    }
    if (input.lookdown)
    {
        camera.horizon -= 2 * (current-time)*0.03;
        input.keypressed = true;
    }
    */
    // Collision detection. Don't fly below the surface.
    var mapoffset = ((Math.floor(camera.y) & (map.width-1)) << map.shift) + (Math.floor(camera.x) & (map.height-1))|0;
    if ((map.altitude[mapoffset]+10) > camera.height) camera.height = map.altitude[mapoffset] + 10;

    time = current;

}

// ---------------------------------------------
// Keyboard and mouse event handlers
// ---------------------------------------------
// Keyboard and mouse event handlers

function GetMousePosition(e)
{
    // fix for Chrome
    if (e.type.startsWith('touch'))
    {
        return [e.targetTouches[0].pageX, e.targetTouches[0].pageY];
    } else
    {
        return [e.pageX, e.pageY];
    }
}


function DetectMouseDown(e)
{
    input.forwardbackward = 3.;
    input.mouseposition = GetMousePosition(e);
    time = new Date().getTime();

    if (!updaterunning) Draw();
    return;
}

function DetectMouseUp()
{
    input.mouseposition = null;
    input.forwardbackward = 0;
    input.leftright = 0;
    input.updown = 0;
    return;
}

function DetectMouseMove(e)
{
    e.preventDefault();
    if (input.mouseposition == null) return;
    if (input.forwardbackward == 0) return;

    var currentMousePosition = GetMousePosition(e);

    input.leftright = (currentMousePosition[0] - input.mouseposition[0]) / window.innerWidth * 2;
    //camera.horizon  = 0 + (input.mouseposition[1] - currentMousePosition[1]) / window.innerHeight * 280;
    //input.updown    = (input.mouseposition[1] - currentMousePosition[1]) / window.innerHeight * 10;
}


function DetectKeysDown(e)
{
    let screenwidth = screendata.canvas.width|0;
    let keyTurnRate = 100.;
    switch(e.keyCode)
    {
    case 37:    // left cursor
    case 65:    // a
        
        break;
    case 39:    // right cursor
    case 68:    // d
        
        break;
    case 38:    // cursor up
    case 87:    // w
        input.forwardbackward = 3.;
        break;
    case 40:    // cursor down
    case 83:    // s
        input.forwardbackward = -3.;
        break;
    case 82:    // r
        input.updown = +2.;
        break;
    case 70:    // f
        input.updown = -2.;
        break;
    case 81:    //q
        //input.lookdown = true;
        input.leftright = -1. * keyTurnRate / screenwidth;
        break;
    case 69:    // e
        //input.lookup = true;
        input.leftright = +1. * keyTurnRate / screenwidth;
        break;
     default:
        return;
        break;
    }

    if (!updaterunning) {
        time = new Date().getTime();
        Draw();
    }
    return false;
}

function DetectKeysUp(e)
{
    switch(e.keyCode)
    {
    case 37:    // left cursor
    case 65:    // a
        
        break;
    case 39:    // right cursor
    case 68:    // d
        break;
    case 38:    // cursor up
    case 87:    // w
        input.forwardbackward = 0;
        break;
    case 40:    // cursor down
    case 83:    // s
        input.forwardbackward = 0;
        break;
    case 82:    // r
        input.updown = 0;
        break;
    case 70:    // f
        input.updown = 0;
        break;
    case 81:    //q
        input.leftright = 0;
        //input.lookdown = false;
        break;
    case 69:    // e
        input.leftright = 0;
        //input.lookup = false;
        break;
    
    default:
        return;
        break;
    }
    return false;
}

// ---------------------------------------------
// Basic screen handling

function DrawBackground()
{
    var buf32 = screendata.buf32;
    var color = screendata.backgroundcolor|0;
    for (var i = 0; i < buf32.length; i++) buf32[i] = color|0;
}

// Show the back buffer on screen
function Flip()
{
    screendata.imagedata.data.set(screendata.buf8);
    screendata.context.putImageData(screendata.imagedata, 0, 0);
}


var tiltData =
{
    pitchAngle: 0
};

function Init()
{
/*
    //tilt
    for (let i = 0; i < 360; i++)
    {
    tiltData.pitchAngle = i * Math.PI / 180.;
    
    let rad = 1.0;
    let tz = rad * Math.cos(tiltData.pitchAngle);
    let ty = rad * Math.sin(tiltData.pitchAngle);
    console.log();
    let ey = 2.0;
    let yk = 1.0;
    let yc = 280.;
    let ys = (ty - ey) * yk / tz + yc; 
    console.log('pitch='+tiltData.pitchAngle+' tz='+tz+' ty='+ty+' ys='+ys);
    }
    */


    /*
    let steps = 0;
    let deltaz = 1.;
    let deltaincr = 0.01;
    for (let z = 1; z < camera.zFar; z += deltaz) //for each ray step
    {
        deltaz += deltaincr;
        steps++
    }
    console.log("total steps zNear="," to zFar=", camera.zFar, "with delta incr", deltaincr, "is", steps, "with final deltaz", deltaz);
    */
    
    for(var i=0; i<map.width*map.height; i++)
    {
        map.color[i] = 0xFF007050;
        map.altitude[i] = 0;
    }
    LoadMap("C1W;D1");
    OnResizeWindow();

    // set event handlers for keyboard, mouse, touchscreen and window resize
    var canvas = document.getElementById("fullscreenCanvas");
    window.onkeydown    = DetectKeysDown;
    window.onkeyup      = DetectKeysUp;
    canvas.onmousedown  = DetectMouseDown;
    canvas.onmouseup    = DetectMouseUp;
    canvas.onmousemove  = DetectMouseMove;
    canvas.ontouchstart = DetectMouseDown;
    canvas.ontouchend   = DetectMouseUp;
    canvas.ontouchmove  = DetectMouseMove;

    window.onresize       = OnResizeWindow;

    window.setInterval(function(){
        var current = new Date().getTime();
        document.getElementById('fps').innerText = (frames / (current-timelastframe) * 1000).toFixed(1) + " fps";
        frames = 0;
        timelastframe = current;
    }, 2000);



}

Init();

</script>

</body>
